{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u6b22\u8fce\u5230\u6211\u7684\u535a\u5ba2","text":"<p>\u8fd9\u91cc\u5c06\u8bb0\u5f55\u4e00\u4e9b\u5b66\u4e9b\u7684\u7b14\u8bb0</p>"},{"location":"about/","title":"\u5173\u4e8e","text":""},{"location":"about/#_1","title":"\u90a3\u4e2a\u5bb6\u4f19","text":"<ul> <li>\u559c\u6b22\u6e38\u620f\uff0c\u559c\u6b22\u753b\u753b\uff0c\u53c8\u5404\u79cd\u53ef\u4e50\u7684\u5927\u53d4</li> <li>\u6709\u4eba\u8bf4\uff1a\u201c\u4e0d\u4f1a\u753b\u753b\u7684\uff0c\u7a0b\u5e8f\u4e0d\u662f\u597d\u73a9\u5bb6\u3002\u201d</li> <li>\u6211\u89c9\u5f97\uff1a \u8fd9\u8bdd\u5f88\u6709\u201c\u9053\u7406\u201d</li> <li>\u51b2\u9e2d</li> </ul>"},{"location":"index_old/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index_old/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index_old/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"license/","title":"\u8bb8\u53ef","text":""},{"location":"license/#_1","title":"\u535a\u5ba2\u7684\u76ee\u7684","text":"<ul> <li>\u5206\u4eab\u81ea\u5df1\u7684\u4e00\u4e9b\u7ecf\u9a8c\uff0c\u80fd\u591f\u5e2e\u52a9\u5230\u4ed6\u4eba\u3002</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"notes/godot_pitaya/","title":"godot\u8fde\u63a5pitaya","text":""},{"location":"notes/godot_pitaya/#godot-pitaya","title":"godot \u8fde\u63a5 pitaya","text":""},{"location":"notes/godot_pitaya/#_1","title":"\u539f\u7531\uff1a","text":""},{"location":"notes/godot_pitaya/#_2","title":"\u5728\u9009\u62e9\u6e38\u620f\u670d\u52a1\u5668\u6846\u67b6\u7684\u65f6\u5019\u60f3\u5230\u4e86\u4e00\u4e9b\u4e1c\u897f","text":"<ul> <li> <ol> <li>\u9996\u5148\u662f \u5206\u5e03\u5f0f\uff0c\u539f\u56e0\u662f\u5927\u90e8\u5206\u60c5\u51b5\u60f3\u9700\u8981\u90e8\u7f72\u4e0d\u540c\u7684\u4e1c\u897f\u5230\u4e0d\u540c\u7684\u670d\u52a1\u5668\uff0c\u6bd4\u5982\u6570\u636e\u5e93\uff0c\u767b\u5f55\u670d\u52a1\u5668\uff0c\u6e38\u620f\u670d\u52a1\u5668,\u6d3b\u52a8\uff0c\u5728\u4e0d\u540c\u9700\u6c42\u7684\u8bd5\u8bd5\uff0c\u53ef\u80fd\u6dfb\u52a0\u5404\u79cd\u4e1c\u897f\uff0c\u90a3\u4e48\u5206\u5e03\u5f0f\u4e00\u4e2a\u8003\u8651\u7684\u9009\u9879</li> </ol> </li> <li> <ol> <li>\u8bed\u8a00\u7684\u9009\u62e9\u4e0a\uff0cJava,C++,C#,erlang,python,go,\u7b49\u7b49\uff0c <p>Java:    \u4f18\uff1a\u5f88\u7a33\u5b9a\uff0c\u9700\u8981jdk\uff0c   \u52a3\uff1a\u5199\u4ee3\u7801\u90a3\u4e2a\u5927\u5440 C++:   \u4f18\uff1a\u6027\u80fd\u9ad8   \u52a3\uff1a\u5bb9\u6613bug\uff0c\u5d29\u6e83\uff0c\u8981\u6c42\u9ad8\uff0c\u7f16\u8bd1\u8d77\u6765\u9ebb\u70e6 c#: \u4f18\u52a3\u548cjava\u7c7b\u4f3c\uff0c\u5199\u4ee3\u7801\u662f\u4e00\u4ef6\u5f88\u75db\u82e6\u7684\u4e8b\u60c5 erlang: \u4e13\u95e8\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\uff0c\u4f46\u662f\u6211\u6ca1\u600e\u4e48\u63a5\u89e6\uff0c\u88ab\u6401\u7f6e\u4e86 python: \u811a\u672c\u8bed\u8a00\uff0c\u8fd8\u597d\uff0c\u5176\u5b9e\u8fd8\u662f\u4e2a\u4eba\uff0c\u90a3\u8bed\u6cd5\uff0c\u7f29\u8fdb\uff0c\u6211\u4e00\u76f4\u63a5\u7684\u5f88\u5d29\u6e83\uff0c\u627e\u5c3e\u90e8\u4e2d\u95f4\u52a0\u4ee3\u7801\uff0c\u4e5f\u662f\u51e0\u4e2a\u4f53\u529b\u6d3b\uff0c\u90fd\u65e0\u8bed\u4e86\u90fd go:    \u4f18\uff1a\u4e3a\u670d\u52a1\u5668\u8bbe\u8ba1\uff0c\u7f16\u8bd1\u5feb\uff0c\u7a33\u5b9a\u8fd8\u4e0d\u9519   \u52a3\uff1a\u9700\u8981\u719f\u6089\u6574\u4f53</p> </li> </ol> </li> <li> <ol> <li>\u8de8\u5e73\u53f0\uff0c\u90e8\u7f72\u65b9\u9762\u4ee5\u53ca\u73af\u5883\u642d\u5efa\u65b9\u9762\uff0c</li> </ol> </li> </ul>"},{"location":"notes/godot_pitaya/#go","title":"\u6700\u7ec8\u9009\u62e9go\u8bed\u8a00","text":""},{"location":"notes/godot_pitaya/#_3","title":"\u6846\u67b6\u9009\u62e9\u65b9\u9762","text":"<ul> <li> <ol> <li>\u5b89\u88c5\u7b80\u5355 \u5b89\u88c5\u8d77\u6765\u5374\u8fd9\u5374\u90a3\u7684\uff0clinux\u592a\u5e38\u89c1\u4e86\uff0c\u6298\u78e8</li> </ol> </li> <li> <ol> <li>\u5206\u5e03\u5f0f \u6211\u81ea\u5df1\u5728\u9020\u8f6e\u5b50\uff0c\u5199\u8d77\u6765\u7c7b</li> </ol> </li> <li> <ol> <li>\u6709\u5728\u66f4\u65b0 \u6280\u672f\u66f4\u65b0\u5feb\uff0c\u6ca1\u6709\u66f4\u65b0\u53ef\u80fd\u90fd\u6709\u53ef\u80fd\u6dd8\u6c70\u4e86</li> </ol> </li> </ul>"},{"location":"notes/godot_pitaya/#pitaya","title":"\u6682\u65f6\u9009\u62e9pitaya","text":"<ul> <li>\u6709\u5728\u66f4\u65b0</li> <li>\u4ed6\u4eec\u6709\u5728\u4f7f\u7528\u6846\u67b6</li> <li>\u5199\u8d77\u6765\u4e5f\u8fd8\u7b97\u4e0d\u96be</li> </ul>"},{"location":"notes/godot_pitaya/#godot","title":"\u5ba2\u6237\u7aef \u9009\u62e9godot \u56e0\u4e3a\u5f00\u6e90\uff0c\u6574\u4f53\u4f7f\u7528\u8fd8\u4e0d\u9519","text":"<ul> <li>unity \u6ca1\u94b1\uff0c\u52a0\u5404\u79cd\u767b\u5f55\uff0c\u5404\u79cd\u4f5c\u5996</li> <li>ue  \u592a\u5927\u4e86\uff0c\u6211\u7b14\u8bb0\u672c\u73a9\u4e0d\u8f6c\uff0c\u6709\u70b9\u725b\u5200\u6233\u8682\u8681\u7684\u611f\u89c9</li> </ul>"},{"location":"notes/godot_pitaya/#_4","title":"\u5f00\u59cb\u6b63\u9898","text":"<p>**\u7248\u672c\u9009\u62e9 - godot 4.6 - pitaya v2@2.11.21 - \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u9879\u76ee \u4e0a\u4f20\u5230github https://github.com/hcqmaker/sharething/blob/master/godot_pitaya.7z \u4e0d\u60f3\u4e0b\u8f7d\uff0c\u53ef\u4ee5\u76f4\u63a5\u4e0b\u9762\u770b\u4ee3\u7801</p>"},{"location":"notes/godot_pitaya/#_5","title":"\u670d\u52a1\u5668\u90e8\u5206","text":"<p>\u670d\u52a1\u5668\u53c2\u8003\u7684\u662fdemo chat</p>"},{"location":"notes/godot_pitaya/#maingo","title":"main.go","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n\n    \"github.com/topfreegames/pitaya/v2/groups\"\n\n    \"strings\"\n\n    \"github.com/topfreegames/pitaya/v2\"\n    \"github.com/topfreegames/pitaya/v2/acceptor\"\n    \"github.com/topfreegames/pitaya/v2/component\"\n    \"github.com/topfreegames/pitaya/v2/config\"\n    \"github.com/topfreegames/pitaya/v2/logger\"\n    \"github.com/topfreegames/pitaya/v2/timer\"\n)\n\ntype (\n    Room struct {\n        component.Base\n        timer *timer.Timer\n        app   pitaya.Pitaya\n    }\n\n    UserMessage struct {\n        Name    string `json:\"name\"`\n        Content string `json:\"content\"`\n    }\n\n    NewUser struct {\n        Content string `json:\"content\"`\n    }\n\n    AllMembers struct {\n        Members []string `json:\"members\"`\n    }\n\n    JoinResponse struct {\n        Code   int    `json:\"code\"`\n        Result string `json:\"result\"`\n    }\n)\n\nfunc NewRoom(app pitaya.Pitaya) *Room {\n    return &amp;Room{\n        app: app,\n    }\n}\n\nfunc (r *Room) AfterInit() {\n    r.timer = pitaya.NewTimer(time.Minute, func() {\n        count, err := r.app.GroupCountMembers(context.Background(), \"room\")\n        logger.Log.Debugf(\"UserCount: Time=&gt; %s, Count=&gt; %d, Error=&gt; %v\", time.Now().String(), count, err)\n    })\n}\n\nfunc (r *Room) Join(ctx context.Context, msg []byte) (*JoinResponse, error) {\n\n    s := r.app.GetSessionFromCtx(ctx)\n    fakeUID := s.ID()                              // just use s.ID as uid !!!\n    err := s.Bind(ctx, strconv.Itoa(int(fakeUID))) // binding session uid\n\n    if err != nil {\n        return nil, pitaya.Error(err, \"RH-000\", map[string]string{\"failed\": \"bind\"})\n    }\n\n    uids, err := r.app.GroupMembers(ctx, \"room\")\n    if err != nil {\n        return nil, err\n    }\n    s.Push(\"onMembers\", &amp;AllMembers{Members: uids})\n    r.app.GroupBroadcast(ctx, \"chat\", \"room\", \"onNewUser\", &amp;NewUser{Content: fmt.Sprintf(\"New user: %s\", s.UID())})\n    r.app.GroupAddMember(ctx, \"room\", s.UID()) // add session to group\n\n    s.OnClose(func() {\n        r.app.GroupRemoveMember(ctx, \"room\", s.UID())\n    })\n\n    return &amp;JoinResponse{Result: \"success\"}, nil\n}\n\nfunc (r *Room) Message(ctx context.Context, msg *UserMessage) {\n    err := r.app.GroupBroadcast(ctx, \"chat\", \"room\", \"onMessage\", msg)\n    if err != nil {\n        fmt.Println(\"error broadcasting message\", err)\n    }\n}\n\nvar app pitaya.Pitaya\n\nfunc main() {\n    conf := config.NewDefaultPitayaConfig()\n    conf.Buffer.Handler.LocalProcess = 15\n    conf.Heartbeat.Interval = time.Duration(15 * time.Second)\n    conf.Buffer.Agent.Messages = 32\n    conf.Handler.Messages.Compression = false\n    // Standalone \u72ec\u7acb\u6a21\u5f0f\n    builder := pitaya.NewDefaultBuilder(true, \"chat\", pitaya.Standalone, map[string]string{}, *conf)\n    // Cluster \u96c6\u7fa4\u6a21\u5f0f \u9700\u8981 etcd, nats, \u770b\u60c5\u51b5\u8fd8\u6709\u53ef\u80fd\u9700\u8981\u5f00\u542fredis\n    //builder := pitaya.NewDefaultBuilder(true, \"chat\", pitaya.Cluster, map[string]string{}, *conf)\n    builder.AddAcceptor(acceptor.NewTCPAcceptor(\":3251\"))\n    builder.Groups = groups.NewMemoryGroupService(builder.Config.Groups.Memory)\n    app = builder.Build()\n\n    defer app.Shutdown()\n\n    err := app.GroupCreate(context.Background(), \"room\")\n    if err != nil {\n        panic(err)\n    }\n\n    // rewrite component and handler name\n    room := NewRoom(app)\n    app.Register(room,\n        component.WithName(\"room\"),\n        component.WithNameFunc(strings.ToLower),\n    )\n\n    app.Start()\n}\n\n</code></pre>"},{"location":"notes/godot_pitaya/#_6","title":"\u5ba2\u6237\u7aef\u90e8\u5206","text":"<ul> <li>\u5728 https://blog.csdn.net/weixin_44627989/article/details/130355014 \u4e0a\u7684\u4ee3\u7801\u57fa\u7840\u4e0a\u8fdb\u884c\u7684\u4fee\u6539\u5b8c\u6210</li> </ul> <p>\u5ba2\u6237\u7aef\u7684\u8bbe\u8ba1</p> <pre><code>    Control         Control   main.gd\n        client      Node      client.gd\n\n        txtContent  TextEdit\n        txtInput    TextEdit\n        txtNickName LineEdit\n\n        btnConnected Button\n        btnSend      Button\n\n        txtHost      LineEdit\n        txtPort      LineEdit\n</code></pre>"},{"location":"notes/godot_pitaya/#3","title":"\u5ba2\u6237\u7aef\u4ee3\u7801\u8bbe\u8ba13\u4e2a\u811a\u672c","text":""},{"location":"notes/godot_pitaya/#maingd","title":"main.gd","text":"<pre><code>extends Control\n\n@onready var client: Client = $client\n\n@onready var txt_port: LineEdit = $txtPort\n@onready var txt_host: LineEdit = $txtHost\n@onready var txt_input: TextEdit = $txtInput\n@onready var txt_nick_name: LineEdit = $txtNickName\n\n@onready var txt_content: TextEdit = $txtContent\n@onready var txt_rtlabel: RichTextLabel = $txtRTLabel\n\n@onready var btn_connected: Button = $btnConnected\n@onready var btn_send: Button = $btnSend\n\n\nfunc _ready() -&gt; void:\n    btn_send.disabled = true;\n    pass\n\nfunc _on_btn_connected_pressed() -&gt; void:\n    var host = txt_host.text;\n    var port = int(txt_port.text);\n\n    client.connect_server(host, port, _rev_connected, _rev_msg);\n    btn_connected.disabled = true;\n    var tween:Tween = create_tween();\n    tween.tween_interval(2);\n    tween.tween_callback(func():\n        if (!client.is_connected_server()):\n            btn_connected.disabled = false;\n        )\n\n    pass # Replace with function body.\n\nfunc _push_msg(uname:String, content:String)-&gt; void:\n    var tmp_str:String = uname + \":\" + content + \"\\n\";\n    txt_content.insert_text_at_caret(tmp_str)\n    #txt_rtlabel.add_text(str);\n    pass\n\n#----------------------------------------------`\nfunc onNewUser(msg) -&gt; void:\n    var data = msg.jsonData();\n    _push_msg('system', data.content);\n    pass\n\nfunc onMembers(msg) -&gt; void:\n    var data = msg.jsonData();\n    _push_msg('system',  \"members: \" + JSON.stringify(data.members));\n    pass\n\nfunc onJoin(succ:bool, msg:Variant, rt:String) -&gt; void:\n    if (!succ):\n        print(\"err not get message rep:\",msg, rt);\n        return;\n    var data = msg.jsonData();\n    if(data.code == 0):\n        _push_msg('system', data.result);\n        client.set_push_func('onMessage', onMessage);\n        #starx.on('onMessage', onMessage)\n    pass\n\nfunc onMessage(msg) -&gt; void:\n    var data = msg.jsonData();\n    _push_msg(data.name, data.content)\n    pass\n\nfunc _rev_connected(succ:bool) -&gt; void:\n    if (succ):\n        print(\"connect to server\");\n        client.set_push_func(\"onNewUser\", onNewUser);\n        client.set_push_func(\"onMembers\", onMembers);\n\n        client.SendRequest(\"room.join\", \"{}\", onJoin);\n        btn_send.disabled = false;\n    else:\n        btn_send.disabled = true;\n        btn_connected.disabled = false;\n    pass\n\nfunc _rev_msg(msg) -&gt; void:\n    print(\"--msg---:\",msg);\n    pass\n\nfunc _on_btn_send_pressed() -&gt; void:\n    if (!client.is_connected_server()):\n        print(\" not connected \")\n        return;\n\n    var nn = txt_nick_name.text;\n    var ctt = txt_input.text;\n\n    var data = JSON.stringify({\"name\": nn, \"content\":ctt }).to_utf8_buffer();\n    client.SendNotify('room.message', data);\n    pass # Replace with function body.\n\n</code></pre>"},{"location":"notes/godot_pitaya/#streamtcpgd","title":"StreamTCP.gd","text":"<pre><code>extends Node\nclass_name StreamTCP\n\n####\n## \u4ece \u590d\u5236\u4e0b\u6765\u8fdb\u884c\u7684\u4fee\u6539\n## https://www.bytesnsprites.com/posts/2021/creating-a-tcp-client-in-godot/\n###\n\nsignal connected\nsignal data\nsignal disconnected\nsignal error\n\nvar _status: int = 0\nvar _stream: StreamPeerTCP = StreamPeerTCP.new()\n\nfunc _ready() -&gt; void:\n    _status = _stream.get_status()\n\nfunc _process(_delta: float) -&gt; void:\n    var new_status: int = _stream.get_status()\n    if new_status != _status:\n        _status = new_status\n        match _status:\n            _stream.STATUS_NONE:\n                print(\"Disconnected from host.\")\n                emit_signal(\"disconnected\")\n            _stream.STATUS_CONNECTING:\n                print(\"Connecting to host.\")\n            _stream.STATUS_CONNECTED:\n                print(\"Connected to host.\")\n                emit_signal(\"connected\")\n            _stream.STATUS_ERROR:\n                print(\"Error with socket stream.\")\n                emit_signal(\"error\")\n\n    if _status == _stream.STATUS_CONNECTED:\n        var available_bytes: int = _stream.get_available_bytes()\n        if available_bytes &gt; 0:\n            #print(\"available bytes: \", available_bytes)\n            var buf_array: Array = _stream.get_partial_data(available_bytes)\n            # Check for read error.\n            if buf_array[0] != OK:\n                print(\"Error getting data from stream: \", buf_array[0])\n                emit_signal(\"error\")\n            else:\n                emit_signal(\"data\", buf_array[1])\n\nfunc is_connected_server() -&gt; bool:\n    var state:int = _stream.get_status();\n    return state == _stream.STATUS_CONNECTED;\n\nfunc connect_to_host(host: String, port: int) -&gt; void:\n    print(\"Connecting to %s:%d\" % [host, port])\n    # Reset status so we can tell if it changes to error again.\n    _status = _stream.STATUS_NONE\n    if _stream.connect_to_host(host, port) != OK:\n        print(\"Error connecting to host.\")\n        emit_signal(\"error\")\n    else:\n        #_stream.set_no_delay(true)\n        _stream.poll();\n\nfunc disconnect_from_host() -&gt; void:\n    if (is_connected_server()):\n        _stream.disconnect_from_host();\n\nfunc send(buff: PackedByteArray) -&gt; bool:\n    if _status != _stream.STATUS_CONNECTED:\n        print(\"Error: Stream is not currently connected.\")\n        return false\n    var err: int = _stream.put_data(buff)\n    if err != OK:\n        print(\"Error writing to stream: \", err)\n        return false\n    return true\n\n</code></pre>"},{"location":"notes/godot_pitaya/#clientgd","title":"client.gd","text":"<pre><code>extends Node\nclass_name  Client\n\n\n\n #/**\n   #* Package protocol encode.\n   #*\n   #* Pomelo package format:\n   #* +------+-------------+------------------+\n   #* | type | body length |       body       |\n   #* +------+-------------+------------------+\n   #*\n   #* Head: 4bytes\n   #*   0: package type,\n   #*      1 - handshake,\n   #*      2 - handshake ack,\n   #*      3 - heartbeat,\n   #*      4 - data\n   #*      5 - kick\n   #*   1 - 3: big-endian body length\n   #* Body: body length bytes\n   #*\n   #* @param  {Number}    type   package type\n   #* @param  {ByteArray} body   body content in bytes\n   #* @return {ByteArray}        new byte array that contains encode result\n   #*/\n\n# 5\u79cd \u57fa\u672c\u7c7b\u578b\u6d88\u606f\n\nconst PACK_TYPE_HANDSHAKE:int = 0x01\nconst PACK_TYPE_HANDSHAKEACK:int = 0x02\nconst PACK_TYPE_HEARTBEAT:int = 0x03\nconst PACK_TYPE_DATA:int = 0x04\nconst PACK_TYPE_KICK:int = 0x05\n\nconst MSG_TYPE_REQUEST:int = 0x00\nconst MSG_TYPE_NOTIFY:int = 0x01\nconst MSG_TYPE_RESPONSE:int = 0x02\nconst MSG_TYPE_PUSH:int = 0x03\n\nconst MSG_MASK_ERROR:int = 0x20\nconst MSG_MASK_GZIP:int = 0x10\nconst MSG_MASK_MSGROUTECOMPRESS:int = 0x01\nconst MSG_MASK_MSGTYPE:int = 0x07\nconst MSG_MASK_SGROUTELENGTH:int = 0xFF\nconst MSG_MASK_MSGHEADLENGTH:int = 0x02\n\nconst HeadLength:int    = 4\nconst MaxPacketSize:int = 1 &lt;&lt; 24 #16MB\n\nvar _wait_cb_array = {}\nvar lastMsgId = 0\nvar clientHandshakeData = null\nvar packet_encoder:PomeloPacketEncoder = null\nvar packet_decoder:PomeloPacketDecoder = null\nvar message_encoder:MessagesEncoder = null\nvar compression:Compression = null\nvar heartbeatTimeout = -1\nvar requestTimeout = 5\nvar serializerType = \"json\";\n\nvar push_func = {}\n\nvar _is_handshake = false;\nvar _is_client_connected = false\n\nconst RECONNECT_TIMEOUT: float = 3.0\n\nvar _host:String = \"127.0.0.1\"\nvar _port:int = 40000;\n#--------------------------------------------------------------\n#--------------------------------------------------------\n# \u9644\u52a0\u56de\u8c03\nvar _cb_connected_func = null;\nvar _cb_msg_func = null;\nvar heartbeatTimer:Timer = null;\n\nfunc is_handshaked() -&gt; bool:\n    return _is_handshake;\n\nfunc is_connected_server() -&gt; bool:\n    return _is_client_connected;\n\nfunc set_push_func(key:String, cb:Callable) -&gt; void:\n    push_func[key] = cb;\n\nfunc del_push_func(key) -&gt; bool:\n    if (push_func.has(key)):\n        push_func.erase(key);\n        return true;\n    return false;\n\nfunc connect_server(host:String, port:int, cbconnected:Callable, cbmsg:Callable):\n    _cb_connected_func = cbconnected;\n    _cb_msg_func = cbmsg;\n    _host = host;\n    _port = port;\n    _stream.connect_to_host(_host, _port);\n\n#--------------------------------------------------------------\n#--------------------------------------------------------------\nvar _stream: StreamTCP = StreamTCP.new()\n\nfunc _ready() -&gt; void:\n    print(\"connect ready\")\n    compression = Compression.new()\n    packet_encoder = PomeloPacketEncoder.new()\n    packet_decoder = PomeloPacketDecoder.new()\n    message_encoder = MessagesEncoder.new()\n    message_encoder.compression = compression\n\n    heartbeatTimer = Timer.new();\n    heartbeatTimer.one_shot = false;\n    heartbeatTimer.autostart = false;\n    heartbeatTimer.timeout.connect(_handle_Heartbeats_send);\n    add_child(heartbeatTimer);\n\n    _stream.connect(\"connected\", _handle_client_connected)\n    _stream.connect(\"disconnected\", _handle_client_disconnected)\n    _stream.connect(\"error\", _handle_client_error)\n    _stream.connect(\"data\", _handle_client_data)\n    add_child(_stream)\n\nfunc _connect_after_timeout(timeout: float) -&gt; void:\n    await get_tree().create_timer(timeout).timeout # Delay for timeout\n    _stream.connect_to_host(_host, _port)\n\nfunc _handle_client_connected() -&gt; void:\n    print(\"Client connected to server.\")\n    _send_handshake();\n\nfunc _handle_client_data(buf: PackedByteArray) -&gt; void:\n    #print(\"rev data len:\",len(buf));\n    _try_read_packs(buf);\n\nfunc _handle_client_disconnected() -&gt; void:\n    print(\"Client disconnected from server.\")\n    _done_client_disconcted();\n    #_connect_after_timeout(RECONNECT_TIMEOUT) # Try to reconnect after 3 seconds\n\nfunc _handle_client_error() -&gt; void:\n    print(\"Client error.\")\n    _done_client_disconcted();\n    #_connect_after_timeout(RECONNECT_TIMEOUT) # Try to reconnect after 3 seconds\n\nfunc _send_handshake() -&gt; void:\n    var hand_shake_data = {\"sys\":{\"clientVersion\":\"1.0\", \"clientBuildNumber\":\"999\",\"platform\":\"pc\"}};\n    var datstr = JSON.stringify(hand_shake_data)\n    var p = packet_encoder.Encode(PACK_TYPE_HANDSHAKE, datstr.to_utf8_buffer())\n    if p == null:\n        print(\"net connect fail\")\n        return\n\n    _stream.send(p)\n\nfunc _try_read_packs(buf:PackedByteArray) -&gt; void:\n    var packets = packet_decoder.Decode(buf)\n    if packets == null:\n        print(\"net read fail len:\" + str(len(buf)))\n        return;\n\n    if (!is_handshaked()):\n        var handshakePacket:Packet = packets[0]\n        if (handshakePacket.Type != PACK_TYPE_HANDSHAKE):\n            print(\"------ get something:\", handshakePacket.Type);\n            return;\n\n        print(\"get handshake type:\", handshakePacket.Type)\n        if compression.IsCompressed(handshakePacket.Data):\n            handshakePacket.Data = compression.InflateData(handshakePacket.Data)\n            if handshakePacket.Data == null:\n                print(\"comp err\")\n                return\n        var handshake = handshakePacket.jsonData();\n        print(\"got handshake from sv, data: \", handshake)\n        var routeDict = {}\n        if (handshake[\"sys\"]):\n            var sys = handshake[\"sys\"];\n            if (sys[\"dict\"]):\n                routeDict = sys[\"dict\"];\n            if (sys[\"heartbeat\"]):\n                heartbeatTimeout = sys[\"heartbeat\"];\n            if (sys[\"serializer\"]):\n                serializerType =  sys[\"serializer\"];\n\n        message_encoder.SetDictionary(routeDict)\n\n        var p = packet_encoder.Encode(PACK_TYPE_HANDSHAKEACK, PackedByteArray())\n        if p == null:\n            return\n\n        _stream.send(p)\n\n        _is_handshake = true;\n        _is_client_connected = true\n\n        heartbeatTimer.wait_time = heartbeatTimeout;\n        heartbeatTimer.start();\n\n        if (_cb_connected_func):\n            _cb_connected_func.call(true);\n\n        return;\n\n    print(\" rev pack num:\",packets.size());\n    for p in packets:\n        _handle_packets(p)\n    pass\n#--------------------------------------------------------------\n\nfunc _newMsgID():\n    lastMsgId += 1\n    return lastMsgId\n\n#SendRequest sends a request to the server\nfunc SendRequest(route:String, data:String, cb):\n    var m = Message.new()\n    m.Type = MSG_TYPE_REQUEST\n    m.ID = _newMsgID()\n    m.Route = route\n    m.Data = data.to_utf8_buffer();\n    m.SendAt = int(Time.get_unix_time_from_system())\n    m.Callback = cb\n    var p = _buildPacket(m)\n    _wait_cb_array[m.ID] = m\n\n    print(\"--- SendRequest route:\", route, \" msgid:\", m.ID);\n    _stream.send(p)\n\n#SendNotify sends a notify to the server\nfunc SendNotify(route:String, data:PackedByteArray):\n    var m = Message.new()\n    m.Type = MSG_TYPE_NOTIFY\n    m.ID = _newMsgID()\n    m.Route = route\n    m.Data = data\n    m.SendAt = int(Time.get_unix_time_from_system())\n    var p = _buildPacket(m)\n    print(\"--- SendNotify route:\", route, \" msgid:\", m.ID);\n    _stream.send(p)\n\nfunc _buildPacket(msg:Message):\n    var encMsg = message_encoder.Encode(msg)\n    var p = packet_encoder.Encode(PACK_TYPE_DATA, encMsg)\n    return p\n\nfunc _handle_Heartbeats_send() -&gt; void:\n    var p = packet_encoder.Encode(PACK_TYPE_HEARTBEAT, PackedByteArray())\n    _stream.send(p)\n\nfunc _handle_packets(p):\n    if p.Type == PACK_TYPE_DATA:\n        #handle data\n        var m = message_encoder.Decode(p.Data)\n        _handle_rev_one_packet(m)\n    elif p.Type == PACK_TYPE_KICK:\n        _done_client_disconcted();\n        print(\"kick from server\");\n    elif p.Type == PACK_TYPE_HEARTBEAT:\n        print(\"------ heartbeat----\");\n        pass\n    else:\n        print(\"-- un oper pack:\", p.Type);\n\nfunc _requestReaper() -&gt; void:\n    if (!is_connected_server()):\n        return;\n    for msgid in _wait_cb_array.keys():\n        var msg:Message = _wait_cb_array[msgid];\n        if (int(Time.get_unix_time_from_system()) - msg.SendAt &gt; requestTimeout):\n            _wait_cb_array.erase(msgid);\n            _handle_timeout_msg(msg);\n\nfunc _handle_rev_one_packet(m:Message):\n    if m.Type == MSG_TYPE_RESPONSE:\n        print(\"--- respones msgid:\", m.ID, \" Route:\", m.Route);\n        if m.ID in _wait_cb_array:\n            var cb_msg = _wait_cb_array[m.ID]\n            _wait_cb_array.erase(m.ID)\n            cb_msg.Callback.call(true, m, \"success\")\n    else:\n        _handle_push_msg(m)\n\nfunc _handle_push_msg(msg:Message):\n    print(\" _handle_push_msg ...msg.Route :\",msg.Route, \" type:\" , msg.Type)\n    var cb_func = push_func.get(msg.Route)\n    if cb_func:\n        cb_func.call(msg)\n    elif (_cb_msg_func):\n        _cb_msg_func.call(msg);\n\nfunc _handle_timeout_msg(msg:Message):\n    msg.Callback.call(false, msg, \" message request is time out\")\n\nfunc _process(_delta: float) -&gt; void:\n    _requestReaper();\n\nfunc _done_client_disconcted() -&gt; void:\n    _is_handshake = false;\n    _is_client_connected = false\n    _stream.disconnect_from_host();\n    heartbeatTimer.stop();\n    if (_cb_connected_func):\n        _cb_connected_func.call(false);\n\nfunc _exit_tree():\n    _done_client_disconcted();\n\n#--------------------------------------------------------------\n# \u53ef\u4ee5\u5728\u4e0b\u9762\u7684\u4f4d\u7f6e\u597d\u5230\u5bf9\u5e94\u7684\u7f16\u7801\u89e3\u7801\u4ee5\u53ca\u6d88\u606f\u7684\u5bf9\u5e94\u5904\u7406\n# github.com/topfreegames/pitaya/v2@v2.11.21/conn\n#--------------------------------------------------------------\nclass Message:\n    var Type:int = 0\n    var ID:int = 0\n    var Route:String = \"\"\n    var Data:PackedByteArray = PackedByteArray()\n    var compressed:bool = false\n    var Err:bool = false\n    var SendAt:int = 0\n    var Callback = null\n\n    func jsonData() -&gt; Variant:\n        return JSON.parse_string(Data.get_string_from_utf8());\n\nclass Packet:\n    var Type:int = -1\n    var Length:int = -1\n    var Data:PackedByteArray = PackedByteArray()\n\n    func jsonData() -&gt; Variant:\n        return JSON.parse_string(Data.get_string_from_utf8());\n\nclass PomeloPacketEncoder:\n#Encode create a packet.Packet from  the raw bytes slice and then encode to network bytes slice\n#Protocol refs: https://github.com/NetEase/pomelo/wiki/Communication-Protocol\n#\n# -&lt;type&gt;-|--------&lt;length&gt;--------|-&lt;data&gt;-\n# --------|------------------------|--------\n# 1 byte packet type, 3 bytes packet data length(big end), and data segment\n    ## return null or PackedByteArray\n    func Encode(typ:int, data:PackedByteArray):\n        if typ &lt; PACK_TYPE_HANDSHAKE || typ &gt; PACK_TYPE_KICK:\n            return null\n        if len(data) &gt; MaxPacketSize:\n            return null\n        var buf = PackedByteArray()\n        buf.append(typ)\n        buf.append_array(IntToBytes(len(data)))\n        buf.append_array(data)\n        return buf\n\n    func IntToBytes(n):\n        var buf = PackedByteArray()\n        buf.append((n &gt;&gt; 16) &amp; 0xFF)\n        buf.append((n &gt;&gt; 8) &amp; 0xFF)\n        buf.append(n &amp; 0xFF)\n        return buf\n\nclass PomeloPacketDecoder:\n\n    func BytesToInt(b):\n        var result = 0\n        for bytev in b:\n            result = int(result&lt;&lt;8) + int(bytev)\n        return result\n\n    func ParseHeader(header):\n        if len(header) != HeadLength:\n            return null\n        var typ = header[0]\n        if typ &lt; PACK_TYPE_HANDSHAKE || typ &gt; PACK_TYPE_KICK:\n            print(\"err header nu\" + str(typ))\n            return null\n        var size = BytesToInt(header.slice(1))\n        if size &gt; MaxPacketSize:\n            print(\"err size\" + str(size))\n            return null\n        return [size, typ]\n\n    #Decode decode the network bytes slice to packet.Packet(s)\n    ## return null or [Packet]\n    func Decode(buf):\n        # check length\n        if len(buf) &lt; HeadLength:\n            print(\"err header 0 \")\n            return null\n\n        # first time\n        var header = buf.slice(0, HeadLength)\n        buf = buf.slice(HeadLength) if len(buf) &gt; HeadLength else []\n        var info = ParseHeader(header)\n        if info == null:\n            print(\"err header 1 \" + str(len(header)))\n            return null\n        var size = info[0]\n        var typ = info[1] \n        var packets = []\n        while size &lt;= len(buf):\n            var p = Packet.new()\n            p.Type = typ\n            p.Length = size\n            packets.append(p)\n            if size &gt; 0:\n                p.Data = buf.slice(0, size)\n                buf = buf.slice(size) if size &lt; len(buf) else []\n            if len(buf) &lt; HeadLength:\n                break\n            header = buf.slice(0, HeadLength)\n            buf = buf.slice(HeadLength) if HeadLength &lt; len(buf) else []\n            info = ParseHeader(header)\n            if info == null:\n                break \n            size = info[0]\n            typ = info[1]\n        return packets\n\nclass MessagesEncoder:\n    var DataCompression = false\n    var compression = null\n    var routes = {}#\u538b\u7f29\u5b57\u5178\n    var codes = {}\n\n    func SetDictionary(dict):\n        if dict == null:\n            return null\n        #routesCodesMutex.Lock()\n        #defer routesCodesMutex.Unlock()\n\n        for route in dict:\n            var code = dict[route]\n            var r = route.replace(\" \", \"\")\n\n            #duplication check\n            if r in routes:\n                return -1\n            if code in codes:\n                return -2\n            #update map, using last value when key duplicated\n            routes[r] = code\n            codes[code] = r\n\n        return null\n\n    #GetDictionary gets the routes map which is used to compress route.\n    func GetDictionary() -&gt; Dictionary:\n        #routesCodesMutex.RLock()\n        #defer routesCodesMutex.RUnlock()\n        var dict = {}\n        for k in routes:\n            dict[k] = routes[k]\n        return dict\n\n    func routable(t) -&gt; bool:\n        return t == MSG_TYPE_REQUEST || t == MSG_TYPE_NOTIFY || t == MSG_TYPE_PUSH\n\n    func invalidType(t) -&gt; bool:\n        return t &lt; MSG_TYPE_REQUEST || t &gt; MSG_TYPE_PUSH\n\n    func Uint16(b) -&gt; int:\n        var b1 = b[1] &amp; 0xFFFF\n        var b2 = (b[0] &amp; 0xFFFF)&lt;&lt;8\n        return b1 | b2\n\n#// Encode marshals message to binary format. Different message types is corresponding to\n#// different message header, message types is identified by 2-4 bit of flag field. The\n#// relationship between message types and message header is presented as follows:\n#// ------------------------------------------\n#// |   type   |  flag  |       other        |\n#// |----------|--------|--------------------|\n#// | request  |----000-|&lt;message id&gt;|&lt;route&gt;|\n#// | notify   |----001-|&lt;route&gt;             |\n#// | response |----010-|&lt;message id&gt;        |\n#// | push     |----011-|&lt;route&gt;             |\n#// ------------------------------------------\n#// The figure above indicates that the bit does not affect the type of message.\n#// See ref: https://github.com/topfreegames/pitaya/v2/blob/master/docs/communication_protocol.md\n\n    func Encode(message:Message):\n        if invalidType(message.Type):\n            return null\n        var buf:PackedByteArray = PackedByteArray()\n        var flag = (message.Type &amp; 0xFF) &lt;&lt; 1\n\n        #routesCodesMutex.RLock()\n        var compressed = message.Route in routes\n        var code = routes.get(message.Route)\n\n        #routesCodesMutex.RUnlock()\n        if compressed:\n            flag |= MSG_MASK_MSGROUTECOMPRESS\n\n        if message.Err:\n            flag |= MSG_MASK_ERROR\n\n        buf.append(flag)\n\n        if message.Type == MSG_TYPE_REQUEST || message.Type == MSG_TYPE_RESPONSE:\n            var n:int = message.ID\n            #variant length encode\n            while true:\n                var b = (n % 128) &amp; 0xFF\n                n = int(n/128.0);\n                if n != 0:\n                    buf.append(b+128)\n                else:\n                    buf.append(b)\n                    break\n\n        if routable(message.Type):\n            if compressed:\n                buf.append((code&gt;&gt;8)&amp;0xFF)\n                buf.append(code&amp;0xFF)\n            else:\n                buf.append(len(message.Route)&amp;0xFF)\n                buf.append_array(message.Route.to_utf8_buffer())\n\n\n        if DataCompression:\n            var d = compression.DeflateData(message.Data)\n            if d == null:\n                return null\n\n            if len(d) &lt; len(message.Data):\n                message.Data = d\n                buf[0] |= MSG_MASK_GZIP\n\n        buf.append_array(message.Data)\n        return buf\n\n\n    # github.com/topfreegames/pitaya/v2@v2.11.21/conn\n    # Decode unmarshal the bytes slice to a message\n    # See ref: https://github.com/topfreegames/pitaya/v2/blob/master/docs/communication_protocol.md\n    func Decode(data) -&gt; Message:\n        if len(data) &lt; MSG_MASK_MSGHEADLENGTH:\n            return null\n        var m = Message.new()\n        var flag = data[0]\n        var offset = 1\n        m.Type = (0xFF &amp; (flag &gt;&gt; 1)) &amp; MSG_MASK_MSGTYPE\n\n        if invalidType(m.Type):\n            return null\n\n        if m.Type == MSG_TYPE_REQUEST || m.Type == MSG_TYPE_RESPONSE:\n            var id = 0\n            # little end byte order\n            # WARNING: must can be stored in 64 bits integer\n            # variant length encode\n            for i in range(offset, len(data)):\n                var b = data[i];\n                id += (b&amp;0x7F) &lt;&lt; int(7*(i-offset));\n                if b &lt; 128:\n                    offset = i + 1\n                    break\n\n            #var i = offset\n            #while i &lt; len(data):\n                #var b = data[i]\n                #id += (b&amp;0x7F) * int(pow(2, (7 *i)))\n                #if b &lt; 128:\n                    #offset = i + 1\n                    #break\n                #i += 1 \n\n            m.ID = id\n\n        m.Err = flag&amp;MSG_MASK_ERROR == MSG_MASK_ERROR\n\n        if routable(m.Type):\n            if flag&amp;MSG_MASK_MSGROUTECOMPRESS == 1:\n                m.compressed = true\n                var code = Uint16(data.slice(offset, offset + 2))\n                #routesCodesMutex.RLock()\n                var route = codes.get(code, null)\n                #routesCodesMutex.RUnlock()\n                if route == null:\n                    return null\n\n                m.Route = route\n                offset += 2\n            else:\n                m.compressed = false\n                var rl = data[offset]\n                offset += 1\n                var valb = data.slice(offset, offset + int(rl))\n                m.Route = valb.get_string_from_utf8()\n                offset += int(rl)\n\n\n        m.Data = data.slice(offset)\n        if flag&amp;MSG_MASK_GZIP == MSG_MASK_GZIP:\n            m.Data = compression.InflateData(m.Data)\n            if m.Data == null:\n                return null\n\n        return m\n\nclass Compression:\n    func DeflateData(_data) -&gt; PackedByteArray:\n        var bb = PackedByteArray()\n        #\u672a\u5b9e\u73b0\n        return bb\n\n    func InflateData(_data) -&gt; PackedByteArray:\n        var bb = PackedByteArray()\n        #\u672a\u5b9e\u73b0\n        return bb\n\n    func IsCompressed(data) -&gt; bool:\n        return len(data) &gt; 2 &amp;&amp;(\n            # zlib\n            (data[0] == 0x78 &amp;&amp;\n            (data[1] == 0x9C ||\n            data[1] == 0x01 ||\n            data[1] == 0xDA ||\n            data[1] == 0x5E)) ||\n            #gzip\n            (data[0] == 0x1F &amp;&amp; data[1] == 0x8B))\n\n</code></pre>"}]}